* Super duper config

** General settings


*** Start-up behavior

***** Start-up screen

    #+begin_src emacs-lisp
      (setq inhibit-startup-screen t)
    #+end_src

***** visual line mode

    #+begin_src emacs-lisp
      (global-visual-line-mode t)
    #+end_src    


*** UI Settings
   
***** Customize line numbers

    #+begin_src emacs-lisp
      (global-display-line-numbers-mode)
      (setq display-line-numbers-type 'relative)
    #+end_src

***** Hide UI bars

    Hide the menu bar, tool bar and scroll bar. Doing so early avoids ever having to see them - not even for a brief flash when starting Emacs.
    Toggle them on and off using M-x tool-bar-mode etc.
    #+begin_src emacs-lisp
      (if (fboundp 'menu-bar-mode) (menu-bar-mode -1))
      (if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
      (if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
    #+end_src

***** Enable word wrap

    This enables wrapping but kill-line still kills the whole line.
    
    #+begin_src emacs-lisp
      (setq-default word-wrap t)
    #+end_src

***** Highlight current line

    This highlights the current line in the buffer
    
    #+begin_src emacs-lisp
      (global-hl-line-mode t)
    #+end_src

***** Change how dired looks

      Make dired less verbose.
      You can toggle this on and off using "("

      #+begin_src emacs-lisp
	;; (dired-hide-details-mode 1)
      #+end_src


** Custom snippets
***** auto-refresh

    How to have Emacs auto-refresh all buffers when files have changed on disk?
    
    #+begin_src emacs-lisp
      (global-auto-revert-mode t)
    #+end_src

    Auto refresh dired buffers, but be quiet about it.
    The last line makes sure that you are not alerted every time this happens.

    #+begin_src emacs-lisp
      (setq global-auto-revert-non-file-buffers t)
      (setq auto-revert-verbose nil)
    #+end_src
***** Navigation in dired

    In dired, M-> and M- never take me where I want to go.
    With this code, instead of taking me to the very beginning or very end, they now take me to the first or last file.
    #+begin_src emacs-lisp
      (defun dired-back-to-top ()
        (interactive)
        (beginning-of-buffer)
        (dired-next-line 4))
      (define-key dired-mode-map
        (vector 'remap 'beginning-of-buffer) 'dired-back-to-top)
      (defun dired-jump-to-bottom ()
        (interactive)
        (end-of-buffer)
        (dired-next-line -1))
      (define-key dired-mode-map
        (vector 'remap 'end-of-buffer) 'dired-jump-to-bottom)  
    #+end_src
***** Join lines

     With point anywhere on the first line, I simply press M-j multiple times to pull the lines up.

     #+begin_src emacs-lisp
       (global-set-key (kbd "M-j")
            (lambda ()
                  (interactive)
                  (join-line -1)))
     #+end_src
***** Delete current buffer

    C-x C-k: file begone!

    I like the feel between C-x k to kill the buffer and C-x C-k to kill the file. Release ctrl to kill it a little, hold to kill it a lot.

    #+begin_src emacs-lisp
      (defun delete-current-buffer-file ()
      "Removes file connected to current buffer and kills buffer."
      (interactive)
      (let ((filename (buffer-file-name))
            (buffer (current-buffer))
            (name (buffer-name)))
        (if (not (and filename (file-exists-p filename)))
            (ido-kill-buffer)
          (when (yes-or-no-p "Are you sure you want to remove this file? ")
            (delete-file filename)
            (kill-buffer buffer)
            (message "File '%s' successfully removed" filename)))))

      (global-set-key (kbd "C-x C-k") 'delete-current-buffer-file)
    #+end_src
***** Rename current buffer    

    You don't have to type the name out from scratch - but get the current name to modify.

    #+begin_src emacs-lisp
      (defun rename-current-buffer-file ()
        "Renames current buffer and file it is visiting."
        (interactive)
        (let ((name (buffer-name))
              (filename (buffer-file-name)))
          (if (not (and filename (file-exists-p filename)))
              (error "Buffer '%s' is not visiting a file!" name)
            (let ((new-name (read-file-name "New name: " filename)))
              (if (get-buffer new-name)
                  (error "A buffer named '%s' already exists!" new-name)
                (rename-file filename new-name 1)
                (rename-buffer new-name)
                (set-visited-file-name new-name)
                (set-buffer-modified-p nil)
                (message "File '%s' successfully renamed to '%s'"
                         name (file-name-nondirectory new-name)))))))

      (global-set-key (kbd "C-x C-r") 'rename-current-buffer-file)
    #+end_src

***** Copy file path to clipboard in Emacs

    You don't have to type the name out from scratch - but get the current name to modify.

    #+begin_src emacs-lisp
    (defun my-put-file-name-on-clipboard ()
      "Put the current file name on the clipboard"
      (interactive)
      (let ((filename (if (equal major-mode 'dired-mode)
                          default-directory
                        (buffer-file-name))))
        (when filename
          (with-temp-buffer
            (insert filename)
            (clipboard-kill-region (point-min) (point-max)))
          (message filename))))
    #+end_src
***** Open new lines above or below the current line

    With these shortcuts you can open a new line above or below the current one, even if the cursor is midsentence.

    These are not very helpful if you are using evil-mode.

    #+begin_src emacs-lisp
      (defun open-line-below ()
        (interactive)
        (end-of-line)
        (newline)
        (indent-for-tab-command))

      (defun open-line-above ()
        (interactive)
        (beginning-of-line)
        (newline)
        (forward-line -1)
        (indent-for-tab-command))
      
      (global-set-key (kbd "<C-return>") 'open-line-below)
      (global-set-key (kbd "<C-S-return>") 'open-line-above)
    #+end_src
***** Move around in a buffer quickly

     Are Ctrl-n and Ctrl-p too slow for you?
     Move in a buffer more quickly.

     These are not very helpful if you are using evil-mode.

     #+begin_src emacs-lisp
       (global-set-key (kbd "C-S-n")
                (lambda ()
                  (interactive)
                  (ignore-errors (next-line 5))))

       (global-set-key (kbd "C-S-p")
                       (lambda ()
                         (interactive)
                         (ignore-errors (previous-line 5))))
       
       (global-set-key (kbd "C-S-f")
                       (lambda ()
                         (interactive)
                         (ignore-errors (forward-char 5))))
       
       (global-set-key (kbd "C-S-b")
                       (lambda ()
                         (interactive)
                         (ignore-errors (backward-char 5))))
     #+end_src


** Packages

***** rg

    Use rg in emacs
    
    #+begin_src emacs-lisp
      (use-package rg
        :ensure t
        :config 
        (rg-enable-default-bindings)
      )
    #+end_src

    To edit the results buffer, you need to wgrep-change-to-wgrep-mode

    Make the search results editable by enabling ~wgrep~ mode.  When
    done press ~C-c C-c~ to commit your changes to the underlying files
    or ~C-c C-k~ to drop the changes.

    You can save the results of a particular search by using the letter ~s~
    You can navigate to it exactly the same way you navigate to all the buffers - using ~Ctrl X b~

***** auto-complete    

    Not using auto-complete for now because I am using Company instead.
    
    #+begin_src emacs-lisp
      ;;(use-package auto-complete
      ;;  :ensure t
      ;;  :config 
      ;;  (ac-config-default)
      ;;  )
    #+end_src

***** avy

    https://github.com/abo-abo/avy

    #+begin_src emacs-lisp
      (use-package avy
        :config 
          (global-set-key (kbd "C-c jc1") 'avy-goto-char)
          (global-set-key (kbd "C-c jc2") 'avy-goto-char-2)
          (global-set-key (kbd "C-c jl") 'avy-goto-line)
          (global-set-key (kbd "C-c jw") 'avy-goto-word-1)
          (global-set-key (kbd "C-c ja") 'avy-goto-word-0)
          ;;(global-set-key (kbd "C-c at") 'avy-goto-char-timer)
          :ensure t)
    #+end_src

***** beacon

    This applies a beacon effect to the highlighted line
    
    #+begin_src emacs-lisp
      (use-package beacon 
         :ensure t
         :config
         (beacon-mode 1))
    #+end_src

***** cl-lib

    #+begin_src emacs-lisp
      (use-package cl-lib
        :ensure t)
    #+end_src

***** company

    http://company-mode.github.io/
    
    #+begin_src emacs-lisp
      (use-package company
        :ensure t
        :init
        (add-hook 'after-init-hook 'global-company-mode)
        (setq company-dabbrev-downcase nil)
        (setq company-dabbrev-ignore-case nil)
      )
    #+end_src

***** dracula theme

    Use t in (load-theme 'dracula t) to make sure that it wouldn't ask for confirmation at start-up.
    
    #+begin_src emacs-lisp
      (use-package dracula-theme
         :config
         (load-theme 'dracula t)
         :ensure t)
    #+end_src

***** flex-autopair

    #+begin_src emacs-lisp
      (use-package flex-autopair
        :ensure t
        :config
          (flex-autopair-mode 1)
      )
    #+end_src

***** flycheck

    https://github.com/flycheck/flycheck

    #+begin_src emacs-lisp
      (use-package flycheck
        :ensure t)
    #+end_src

***** git-gutter

    #+begin_src emacs-lisp
      (use-package git-gutter
        :ensure t
        :config
          (global-git-gutter-mode +1)
      )
    #+end_src
      
***** haskell-mode

    #+begin_src emacs-lisp
      (use-package haskell-mode
        :ensure t)
    #+end_src

***** hydra

    #+begin_src emacs-lisp
      ;; (global-set-key (kbd "M-g M-g") 'hydra-git-gutter/body)
      ;;
      ;; (defhydra hydra-git-gutter (:body-pre (git-gutter-mode 1)
      ;;                             :hint nil)
      ;;   "
      ;;   Git gutter:
      ;;     _j_: next hunk        _s_tage hunk     _q_uit
      ;;     _k_: previous hunk    _r_evert hunk    _Q_uit and deactivate git-gutter
      ;;     ^ ^                   _p_opup hunk
      ;;     _h_: first hunk
      ;;     _l_: last hunk        set start _R_evision
      ;;   "
      ;;     ("j" git-gutter:next-hunk)
      ;;     ("k" git-gutter:previous-hunk)
      ;;     ("h" (progn (goto-char (point-min))
      ;;                 (git-gutter:next-hunk 1)))
      ;;     ("l" (progn (goto-char (point-min))
      ;;                 (git-gutter:previous-hunk 1)))
      ;;     ("s" git-gutter:stage-hunk)
      ;;     ("r" git-gutter:revert-hunk)
      ;;     ("p" git-gutter:popup-hunk)
      ;;     ("R" git-gutter:set-start-revision)
      ;;     ("q" nil :color blue)
      ;;     ("Q" (progn (git-gutter-mode -1)
      ;;                 ;; git-gutter-fringe doesn't seem to
      ;;                 ;; clear the markup right away
      ;;                 (sit-for 0.1)
      ;;                 (git-gutter:clear))
      ;;          :color blue))
      ;;
      ;;  (use-package hydra
      ;;    :ensure t)
    #+end_src

***** lsp-java

    Its a good idea to make sure that Java 11 is installed before trying to use lsp-java. Getting it to work with Java 8 wasn't successful.
    
    #+begin_src emacs-lisp
      ;;(use-package lsp-java
      ;;  :config (add-hook 'java-mode-hook 'lsp)
      ;;  :ensure t
      ;;)
    #+end_src
    
    #+begin_src emacs-lisp
      ;;(use-package dap-mode
      ;;  :after lsp-mode
      ;;  :config (dap-auto-configure-mode)
      ;;  :ensure t
      ;;)
    #+end_src

    #+begin_src emacs-lisp
      ;;(use-package dap-java
      ;;  :ensure t
      ;;)
    #+end_src
    
    #+begin_src emacs-lisp
      ;;(use-package helm-lsp
      ;;  :ensure t
      ;;)
    #+end_src
    
    #+begin_src emacs-lisp
      ;;(use-package lsp-treemacs
      ;;  :ensure t
      ;;)
    #+end_src

***** lsp-mode

    #+begin_src emacs-lisp
      ;;(use-package lsp-mode
      ;;  :hook ((lsp-mode . lsp-enable-which-key-integration))
      ;;  :config (setq lsp-completion-enable-additional-text-edit nil)
      ;;  :ensure t
      ;;)
    #+end_src

***** lsp-ui

    #+begin_src emacs-lisp
      ;;(use-package lsp-ui
      ;;  :ensure t)
    #+end_src

***** magit

    (When this gets reasonably big, pull this section into a separate file of its own.)
    To launch magit when you are editing a file that is in a git repository, ~Ctrl c g~

    To see the diff version of a file in the magit status page, with the mouse on that file, hit ~tab~. To close the diff view, hit tab again.

    After staging all the files we want to commit, to commit them, hit ~Ctrl c Ctrl c~
    Enter a commit message and hit ~Ctrl c Ctrl c~

    After you have a commit, to push it to the remote repository, hit ~P~. It gives you options about where to push it and some other details.

    https://magit.vc/manual/magit/Resolving-Conflicts.html

    #+begin_src emacs-lisp
      (use-package magit
		:ensure t
		:config
			(defadvice magit-status (around magit-fullscreen activate)
		  (window-configuration-to-register :magit-fullscreen)
		  ad-do-it
		  (delete-other-windows))

		(defadvice magit-mode-quit-window (after magit-restore-screen activate)
		  "Restores the previous window configuration and kills the magit buffer"
		  (jump-to-register :magit-fullscreen))

		(define-key magit-status-mode-map (kbd "q") 'magit-mode-quit-window)	
      )
    #+end_src

    The config is for this:
    
    Full screen magit-status.
    This code makes magit-status run alone in the frame, and then restores the old window configuration when you quit out of magit.
    No more juggling windows after commiting. It's magit#+begin_src emacs-lisp
    
***** multiple cursors

    Install multiple-cursors and (the dependent package cl-lib) first.
    If you want to start multiple cursors at a word (or a tag or anything) that exists on multiple lines (the lines do not have to be continuous),
    mark the word (using Ctrl space) and then do Ctrl Shift . (dot).
    This will start multiple cursors on the multiple lines.
    After that, you can do normal operations like delete, insert, cut, copy, etc.
    There are a lot of features that can be done using this.
    This needs a lot more research.
    But this should be a good starting point to insert/delete text on multiple lines based on certain common words in multiple lines.0

    https://github.com/magnars/multiple-cursors.el

    #+begin_src emacs-lisp
      (use-package multiple-cursors
        :config
        (global-set-key (kbd "C-S-c C-S-c") 'mc/edit-lines)
        (global-set-key (kbd "C->") 'mc/mark-next-like-this)
        (global-set-key (kbd "C-<") 'mc/mark-previous-like-this)
        (global-set-key (kbd "C-c C-<") 'mc/mark-all-like-this)
        :ensure t)
    #+end_src
    
***** projectile

    https://github.com/bbatsov/projectile
    https://docs.projectile.mx/projectile/index.html
    
    #+begin_src emacs-lisp
      (use-package projectile
        :config
        (projectile-mode +1)
        (define-key projectile-mode-map (kbd "s-p") 'projectile-command-map)
        (define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)
        :ensure t)
    #+end_src

***** evil-mode

    #+begin_src emacs-lisp
      (use-package evil
        :config 
          (evil-mode 1)
        :ensure t)
    #+end_src

***** try

    https://github.com/larstvei/Try

    #+begin_src emacs-lisp
      (use-package try
        :ensure t)
    #+end_src

***** which-key

    #+begin_src emacs-lisp
      (use-package which-key
        :config 
          (setq which-key-idle-delay 0.3)
          (setq which-key-popup-type 'frame)
          (which-key-mode)
          (which-key-setup-minibuffer)
          (set-face-attribute 'which-key-local-map-description-face nil 
             :weight 'bold)
          :ensure t)
    #+end_src

***** yasnippet

    If you don't remember all the shortcuts to various available snippets, use M-x yas-describe-tables to view the available snippets from the documentation.
    
    #+begin_src emacs-lisp
      (add-to-list 'load-path
                    "~/.emacs.d/plugins/yasnippet")
      (use-package yasnippet
        :ensure t
        :config
          (use-package yasnippet-snippets
            :ensure t)
        (yas-reload-all) 
        (yas-global-mode 1)
      )
    #+end_src

**** org-mode and related packages

    How to send notifications from Org Mode planner/schedueler?
    If this works, can this be a replacement for Google Calendar?

***** How to auto save an org document in markdown format?

    To do it automatically,
    install the package ~auto-org-md~ and use ~Meta x auto-org-md-mode~ to toggle the auto save to markdown functionality on and off.
    
    If you turn it on,
    after editing a file in org-mode, when you save it, a markdown version of the file is saved automatically in the same folder that the org file is in.

    Is there a way to do this without using the 'auto-org-md' package?
    This may not be necessary at all. The org files are showing up very nicely in github. So there is no need to export them as markdown files at all.

***** Exporting

You might want to print your notes, publish them on the web, or share them with people not using Org.
Org can convert and export documents to a variety of other formats while retaining as much structure (see Document Structure) and markup (see Markup for Rich Contents) as possible.  

Use ~Ctrl c Ctrl e~ to launch the export command and then use the options displayed to make selections.
e.g. to export as a UTF-8 plain text file, select 't' and 'u'

***** Lists

       How to change the style of bullets?
       e.g. Change a star bullet list into number bullet list. Or vice versa.

       https://orgmode.org/manual/Plain-Lists.html

***** Sorting todo items and items based on priority
      M-x org-sort-entries and then pick the type of entry by which you want to sort.

***** org-mode

    https://orgmode.org/

    #+begin_src emacs-lisp
      (use-package org
	:ensure t
	:config
	  (setq org-log-done 'time) ;;keep track of when a certain TODO item was marked as done.
      )
      (org-babel-do-load-languages
        'org-babel-load-languages '(
	   (shell . t)
	)
      )
    #+end_src

    Agenda Views - First, you need to add your Org file to your Org agenda by using the command C-c [. Then, type Meta-x org-agenda to be presented with options for different views.
      
    How can I show the Org-mode agenda on Emacs start-up
    #+begin_src emacs-lisp
      (add-hook 'after-init-hook 'org-agenda-list)
    #+end_src

***** Table of contents in org mode

    #+begin_src emacs-lisp
        (use-package toc-org
          :ensure t
        )

	(if (require 'toc-org nil t)
	(progn
	  (add-hook 'org-mode-hook 'toc-org-mode)

	  ;; enable in markdown, too
	  ;;(add-hook 'markdown-mode-hook 'toc-org-mode)
	  ;;(define-key markdown-mode-map (kbd "\C-c\C-o") 'toc-org-markdown-follow-thing-at-point)
      )
      (warn "toc-org not found"))
    #+end_src

    1. How to insert table of contents in an org file?
    1. Put a heading in the document. After the line with the heading, add a ~TOC_5~ tag. Change 5 to something else based on the depth that you need for the table of contents.
    1. To add a TOC tag, you can use the command ~org-set-tags-command~ (C-c C-q)
    1. Enter TOC

***** org-roam

https://github.com/org-roam/org-roam

https://www.orgroam.com/manual.html#Keystroke-Index

Prerequisites: Install Graphviz for the Linux distribution

Troubleshooting for the error ~Symbol’s function definition is void~
Install org-roam using this first. And then, use the next script for customizing it. It seems to be having trouble if we try to do all of it at once.
#+begin_src emacs-lisp
   (use-package org-roam
    :ensure t)
#+end_src

After making sure that org-roam is installed successfully (how?), then run the following script for customization.

#+begin_src emacs-lisp
   (use-package org-roam
    :ensure t
    :custom
    (org-roam-directory (file-truename "~/Downloads/GitRepositories/my-personal-wiki"))
    :bind (("C-c n l" . org-roam-buffer-toggle)
	   ("C-c n f" . org-roam-node-find)
	   ("C-c n g" . org-roam-graph)
	   ("C-c n i" . org-roam-node-insert)
	   ("C-c n c" . org-roam-capture)
	   ;; Dailies
	   ("C-c n j" . org-roam-dailies-capture-today))
    :config
    ;; If you're using a vertical completion framework, you might want a more informative completion interface
    (setq org-roam-node-display-template (concat "${title:*} " (propertize "${tags:10}" 'face 'org-tag)))
    (org-roam-db-autosync-mode)
  )
#+end_src

1. ~org-roam-node-insert~ to insert a node in another node. creates a node if it doesn not already exist.
1. ~org-roam-node-find~ to create/insert a new node if it does not already exist; and visits the node.
1. ~org-roam-capture~ creates a node if it does not already exist; restores the current window configuration upon completion.
1. ~org-roam-buffer-toggle~ to open backlinks buffer for a node
1. ~org-id-get-create~ to convert headings in an org file into nodes (instead of creating separate files for small sections)
1. ~org-roam-graph~ to launch a graph view of the org-roam notes

How to rename a note with everything updated at the same time? The references don't seem to get updated. Find a good solution for this.

Rename it within emacs e.g. using dired. Org-roam notices when renaming happens within emacs and will update your links accordingly. If you do it through a file editor, it has no idea!

Rename the #+TITLE in your file and you should see the change in org-roam-find-file. You shouldn’t need to run org-roam-db-build-cache.

If you want the description of links in all of your org-roam files to reflect the TITLE change as well as the filename change – [[file:AAA.org][AAA]] to [[file:ABC.org][ABC]] – looking in the code I think if you rename TITLE first, and then rename the file through dired, your link descriptions should be updated also.

***** org-roam-ui

https://github.com/org-roam/org-roam-ui

Prerequisites: org-roam

#+begin_src emacs-lisp
(use-package org-roam-ui
    :ensure t
    :config
    (setq org-roam-ui-sync-theme t
          org-roam-ui-follow t
          org-roam-ui-update-on-save t
          org-roam-ui-open-on-start t))
#+end_src

Just use ~Meta-X org-roam-ui-open~ and it will launch a tab in the browser with this url: http://localhost:35901/

**** javascript packages

***** js-import

    #+begin_src emacs-lisp
      (use-package js-import
        :ensure t
      )
    #+end_src

***** rjsx-mode

    https://github.com/felipeochoa/rjsx-mode
    
    #+begin_src emacs-lisp
      (use-package rjsx-mode
        :ensure t
        :mode "\\.js\\'"
      )
    #+end_src

***** tide    

    prerequisite for tide: npm install -g typescript

    #+begin_src emacs-lisp
      (defun setup-tide-mode()
        "Setup function for tide."
        (interactive)
        (tide-setup)
        (flycheck-mode +1)
        (setq flycheck-check-syntax-automaticaly '(save mode-enabled))
        (tide-ho-identifier-mode +1)
        (company-mode +1)
      )
    #+end_src
    
    https://github.com/ananthakumaran/tide
    #+begin_src emacs-lisp
      (use-package tide
        :ensure t
        ;; :after (rjsx-mode company flycheck)
        :after (rjsx-mode company)
        :hook (rjsx-mode . setup-tide-mode)
        :config 
        (global-set-key (kbd "C-c jd") 'tide-jump-to-definition)
        (global-set-key (kbd "C-c jb") 'tide-jump-back)
      )
    #+end_src
